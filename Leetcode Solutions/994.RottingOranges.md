# 994. Rotting Oranges
###Â Medium

You are given an m x n grid where each cell can have one of three values:

    0 representing an empty cell,
    1 representing a fresh orange, or
    2 representing a rotten orange.

Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.

 

Example 1:

Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4

Example 2:

Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.

Example 3:

Input: grid = [[0,2]]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        vector<vector<pair<int,int>>> levels;
        int fresh_orange_count = 0;
        
        //Find initially wrotten oranges and put them into the first level
        vector<pair<int,int>> first_level;
        for(int i = 0; i<grid.size(); i++){
            for(int j = 0; j<grid[0].size(); j++){
                if(grid[i][j] == 2)
                    first_level.push_back({i,j});
                if(grid[i][j] == 1)
                    fresh_orange_count++;
            }
        }
        levels.push_back(first_level);
        if(fresh_orange_count == 0) return 0;
        
        //Create a new level and put the infected oranges to these until new level is empty
        while(levels.back().size() > 0){
            vector<pair<int,int>> new_level;
            for(int i = 0; i<levels.back().size(); i++){
                //Add unvisited unadded nieghbors to the next level by looking at all 4 sides and update those oranges from 1 to 2 in the grid

                
                //Up
                if(levels.back()[i].first+1 >= 0 && levels.back()[i].first+1 < grid.size() && 
                   levels.back()[i].second >= 0 && levels.back()[i].second < grid[0].size() && 
                   grid[levels.back()[i].first+1][levels.back()[i].second] == 1
                  ){
                    new_level.push_back({levels.back()[i].first+1, levels.back()[i].second});
                    grid[levels.back()[i].first+1][levels.back()[i].second] = 2;
                }
                
                //Down
                
                if(levels.back()[i].first-1 >= 0 && levels.back()[i].first-1 < grid.size() && 
                   levels.back()[i].second >= 0 && levels.back()[i].second < grid[0].size() && 
                   grid[levels.back()[i].first-1][levels.back()[i].second] == 1
                  ){
                    new_level.push_back({levels.back()[i].first-1, levels.back()[i].second});
                    grid[levels.back()[i].first-1][levels.back()[i].second] = 2;
                }
                
                //Left
                
                if(levels.back()[i].first >= 0 && levels.back()[i].first < grid.size() && 
                   levels.back()[i].second+1 >= 0 && levels.back()[i].second+1 < grid[0].size() && 
                   grid[levels.back()[i].first][levels.back()[i].second+1] == 1
                  ){
                    new_level.push_back({levels.back()[i].first, levels.back()[i].second+1});
                    grid[levels.back()[i].first][levels.back()[i].second+1] = 2;
                }
                
                //Right
                if(levels.back()[i].first >= 0 && levels.back()[i].first < grid.size() && 
                   levels.back()[i].second-1 >= 0 && levels.back()[i].second-1 < grid[0].size() && 
                   grid[levels.back()[i].first][levels.back()[i].second-1] == 1
                  ){
                    new_level.push_back({levels.back()[i].first, levels.back()[i].second-1});
                    grid[levels.back()[i].first][levels.back()[i].second-1] = 2;
                }
            }
            levels.push_back(new_level);
            fresh_orange_count -= new_level.size();
            
        }
        
        if(fresh_orange_count > 0) return -1;
        else return levels.size()-2;
        /
    }

};s
```cpp